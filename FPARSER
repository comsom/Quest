[fparser の仕組み]

ここではプログラム言語 Quest のパーサである fparser の仕組みを、例を通して解説します。
これは元々手計算で考えていたアルゴリズムを実装したもので、
例の中で行う計算は初め手でやっていました。

fparser は上向きの構文解析器であり、
文脈自由文法で表現できる言語のうち、空文字列を認識しないものをパースできます。

fparser に規則の集まり(RULESET)と開始記号(START_SYMBOL)を与えることで、
認識する言語が決まります。

空のトークン列を本体とする規則(A->ε)を持つ規則集を与えることはできません。
fparser がこの規則を扱えないからです。

fparser は forest parser の略です。
このパーサは「与えられた記号から還元の可能性をすべて考える」を基本方針としています。
その可能性の一つ一つは枝(Branch)の積み重ね(stack)から成っているので、
木であると見なすことができます。
そして木の集まりは森(forest)と見なすことができます。
これが forest parser という名前の理由です。







例：
e = e + t | t
t = t * f | f
f = a | ( e )
開始記号は e とする ... 上の規則に root = e を加えた拡大文法を考える。
a, (, ) は終端記号である。

以下で 'a+a...' というトークン列の読み込みを行います。
この計算は usage: ruby grammar.rb g_sum_mul で確かめられます。







-----------------
1トークンの読み込み

a で始まるトークン列 'a...' を解析するとき、以下のような処理が行われています。
> a           ... redposs(e,a) == { f=a }                        ... (1)
> [f=a]       ... redposs(e,f) == { t=f }                        ... (2)
> [t=[f=a]]   ... redposs(e,t) == { e=t ; t=t*f }                ... (3)
> [e=[t=[f=a]]] OR [t=[t=[f=a]]|*f]                              ... (4)
  ... (前者) redposs(e,e) == { e=e+t }, および還元目標へ到達.
  ... (後者) Terminal '*' 待ち。
> Root[e=[t=[f=a]]] OR [e=[e=[t=[f=a]]]|+t] OR [t=[t=[f=a]]|*f]  ... (5)
  ... Root は停止。後ろの2つは Terminal 待ち。
これで a を読んだときの処理を終えます。

-----------
(1)について

まず a が来たので、それを還元しうる規則をすべて見つけます。
これが redposs (reduction possibility)の仕事です。
redposs(<還元目標>, <還元の対象>) は次の2つの集合の共通部分になります：
(a) firstnt を頭部に持つ規則の集合。ここに firstnt は
  「還元目標が生成するトークン列をすべて考えたとき、その頭文字に来うる非終端記号」。
(b) 還元の対象を頭文字とする本体を持つ規則の集合

例えば、 redposs(e,a) の場合、
(a) : firstnts といえるのは e, t, f の三つ。よって (a) は RULESET そのもの。
(b) == (a を頭文字とする本体を持つ規則の集合) == { f=a }
なので、 redposs(e,a) == ((a)と(b)の共通部分) == { f=a } となります。

redposs の計算は、引数さえ与えれば後は文法のみから計算できます。
そのため、文法から予め redposs を計算しておくプログラムがあります： redposs.rb
ここで計算して得たデータは redposs.dat に保存されています。

-----------
(2)について

(1)で redposs を得たら、その規則を用いて「部分還元」を行います。
部分還元の状態は Branch というデータ構造で表され、
この場合は [f=a|] という風に表現されます。
f=a は適応された規則を表し、縦棒(|)はどこまでトークンが部分還元されたかを示しています。
今の場合、縦棒は右端まで達しています。
これは完全に還元が成されたことを表していて、もはや縦棒は不要です。
そのため、(2)では [f=a] という形で表示されています。

還元が成された場合、そこには非終端記号(ここでは f)が現れていると考えられますから、
再び(1)のときのようにこれ(f)の還元可能性を考えています。

----------------
(3)->(4)について

ここでは還元可能性が二つ現れています。
この場合、両方の可能性を考えます。
(4)において OR と出ているのはそのためです。

ここで [e=[t=[f=a]]] や [t=[t=[f=a]]|*f] のことを「可能性」と呼びました。
これらのものは e まで還元されうる「可能性」なのです(class Poss)。

-----------
(4)について

最初の可能性 [e=[t=[f=a]]] は e=t の還元が成されていますから、
さらなる還元可能性を考えます。       ... (A)
それに加え、今回は e が開始記号に一致しています。
これを還元目標へ「到達」したといいます。
還元目標へ到達した場合、(A)の可能性に加え root = e の可能性もあることになるので、
root = e による部分還元を行います。さらにこの場合は必ず還元が成されます。
そして root = e の還元が成った場合には、それ以上の還元可能性は考えません。
この可能性は Root[e=[t=[f=a]]] で表されます。

こうして完成した Root[e=[t=[f=a]]] は、単項式 'a' を表しています。

一方、後者の可能性 [t=[t=[f=a]]|*f] は還元が成されていません。
この場合は終端記号 '*' を待つ状態になります。







---------------------------
(5)の後、さらに1トークンを読む

例として 'a+...' を解析してみます。計算は以下のように行われます：
> Root[e=[t=[f=a]]]:+ OR [e=[e=[t=[f=a]]]|+t]:+ OR [t=[t=[f=a]]|*f]:+  ... (6)
  ... Root[e=[t=[f=a]]]:+ は Root に対する push ... 消える。
  ... [e=[e=[t=[f=a]]]|+t]:+ ... Terminal が match したので部分還元。
  ... [t=[t=[f=a]]|*f]:+     ... Terminal が match しないので消える。
> [e=[e=[t=[f=a]]]+|t]                                                 ... (7)
  ... NonTerminal 't' 待ち。
これで + を読んだときの処理を終えます。

-----------
(6)について

トークンを読むたび、既存の可能性全体の上にそのトークンが1回ずつ push されます。
このように、各可能性は stack になっているのです。
各々の可能性について、 + に対する挙動を見ていきます：
- Root は既に完成している可能性で、これ以上の還元はあり得ません。
  ゆえに何かが push されれば消えてしまいます。
- 真ん中の [e=[e=[t=[f=a]]]|+t]:+ は
  「Terminal '+' 待ち」のところに '+' が来たため、ただちに部分還元を行います。
- [t=[t=[f=a]]|*f]:+ は
  「Terminal '*' 待ち」のところに '+' が来たため、消えてしまいます。







---------------------------
(7)の後、さらに1トークンを読む

例として 'a+a...' を解析してみます。計算は以下のように行われます：
> [e=[e=[t=[f=a]]]+|t]:a         ... redposs(t,a) == { f=a }                 (8)
> [e=[e=[t=[f=a]]]+|t]:[f=a]     ... redposs(t,f) == { t=f }                 (9)
> [e=[e=[t=[f=a]]]+|t]:[t=[f=a]] ... redposs(t,f) == { t=t*f },還元目標へ到達.(10)
> [e=[e=[t=[f=a]]]+|t]:[t=[t=[f=a]]|*f] OR [e=[e=[t=[f=a]]]+[t=[f=a]]]      (11)
  ... (前者) Terminal '*' 待ち。
  ... (後者) redposs(e,e) == { e=e+t }, 還元目標へ到達.
> [e=[e=[t=[f=a]]]+|t]:[t=[t=[f=a]]|*f] OR
  [e=[e=[e=[t=[f=a]]]+[t=[f=a]]]|+t] OR
  Root[e=[e=[t=[f=a]]]+[t=[f=a]]]                                          (12)
  ... 前の二つは Terminal 待ち。 Root は停止。
これで a を読んだときの処理を終えます。

-----------
(8)について

stack の一段深い位置にある [e=[e=[t=[f=a]]]+|t] は NonTerminal 't' を待っています。
これは実は「t を還元目標とせよ」ということなのです。
そのため、ここでは redposs(t,a) を計算しています。

------------
(12)について

ここで完成した Root[e=[e=[t=[f=a]]]+[t=[f=a]]] は単項式の和 'a+a' を表しています。


