# date: 7;2011/2/15 (tue)

require 'arraymethods'
require 'qerror'

module Parser

  #-----------------------------------------------------------------------------
  # set_grammar!
  #-----------------------------------------------------------------------------
  @@ruleset      = :undefined
  @@start_symbol = :undefined
  @@redposs      = :undefined # abbrev: reduction possibility 還元可能性
  # def get_redposs # @@redposs の test のための method : 外から @@redposs を見る。
  #   @@redposs
  # end
  def set_grammar!(rs,ss,rp)
    @@ruleset      = rs
    @@start_symbol = ss
    # ^^^以上が grammar を成す。以下はそれに対応する redposs である。
    @@redposs      = rp
    #puts('debugwrite in set_grammar! : @@redposs : ' + @@redposs.inspect)
  end

  #-----------------------------------------------------------------------------
  # parse
  #-----------------------------------------------------------------------------
  def parse(tokenseq)
    tokenseq.inject([Poss.new([Root.new])]) {|poss_ary, token|
      pa = calc_poss_ary( poss_ary.map{|poss| Poss.new( poss + [token] ) } )
      return QError.new('Parse error : token : ' + token.inspect) if pa.empty?
      pa
    }
  end
  # - poss :abbrev: possibility 可能性
  # - poss_ary の計算 calc_poss_ary
  #     poss_ary の中の Root が完成していない各 poss について inject :
  #       calc_poss(poss) を返す。
  def calc_poss_ary(poss_ary)
    poss_ary.omit{|poss| poss.root.completed? }.concatall {|poss|
      calc_poss(poss)
    }
  end
  
  #-----------------------------------------------------------------------------
  # calc_poss
  #-----------------------------------------------------------------------------
  def calc_poss(poss)
    if poss[-2].redtar.is_nonterminal? # abbrev: reduction target 還元目標
      # 還元可能性の生成(とその後の処理)
      @@redposs[poss[-2].redtar][poss[-1].gsym].concatall {|rule|
        new_poss = poss[0...-1] << Branch.new(rule, [poss[-1]])
        # 回収可能性の生成(とその後の処理)
        collectposses_then_postprocess(new_poss)
      }
    elsif poss[-2].redtar.is_terminal?
      # 還元可能性の生成(とその後の処理)
      if poss.reach2redtar?
        new_poss = poss.collect
        # 回収可能性の生成(とその後の処理)
        collectposses_then_postprocess(new_poss)
      else
        []
      end
    else
      abort 'Abort in calc_poss'
    end
  end
  
  #-----------------------------------------------------------------------------
  # collectposses_then_postprocess
  #-----------------------------------------------------------------------------
  def collectposses_then_postprocess(new_poss)
    # new_poss を可能なだけ回収し、その途上で現れる各可能性に対し計算を行う。
    collect_seq(new_poss).concatall {|p|
      if p[-1].is_Root? or p[-1].not_completed?
        [p]
      elsif p[-1].completed?
        calc_poss(p)
      end
    }
  end
  def collect_seq(poss)
    # poss を回収して得られる可能性の列を返す。
    acc = [poss]
    while true
      p = acc[-1] # abbrev: poss
      #puts('debugwrite in collect_seq : p : ' + p.inspect)
      if p[-1].is_Root?
        break
      elsif p[-1].completed? and p.reach2redtar?
        acc << p.collect
      else
        break
      end
    end
    #puts('debugwrite in collect_seq : acc : ' + acc.inspect)
    acc
  end

  #-----------------------------------------------------------------------------
  # Poss
  #-----------------------------------------------------------------------------
  class Poss < Array
    def initialize(poss)
      # puts('debugwrite in Poss#initialize : self.is_a?(Array) : ' +
      #      self.is_a?(Array).inspect)
      # puts('debugwrite in Poss#initialize : self.class.superclass : ' +
      #      self.class.superclass.inspect)
      # puts('debugwrite in Poss#initialize : self.methods.sort : ' +
      #      self.methods.sort.inspect)
      self << poss.shift until poss.length == 0
    end
    def root
      self[0]
    end
    def collect
      Poss.new( self[0...-2] << self[-2].collect_pterm(self[-1]) )
    end
    # ^^^ pterm :abbrev: poss's term : poss の各要素になりうる object のこと ^^^
    # いいかえると、 Root または Branch または Terminal のこと。
    # NonTerminal は pterm にはなり得ないことに注意(Branch に吸収されるため)。
    def reach2redtar?
      #puts('debugwrite in reach2redtar? : poss : ' + self.inspect)
      self[-2].redtar == self[-1].gsym
    end
    def inspect
      if self.length > 1
        self[1..-1].map{|pterm| pterm.inspect }.join(':')
      elsif self.length == 1
        self[0].inspect # Root の inspect
      end
    end
  end
  
  #-----------------------------------------------------------------------------
  # Root & Branch
  #-----------------------------------------------------------------------------
  class Root
    attr_reader :collection # 解析木を見て計算するときに使う。
    def initialize(collection=[])
      # 開始記号はモジュール変数 @@start_symbol にいれておく。
      @collection = collection
    end
    def completed?
      @collection.length == 1
    end
    def not_completed?
      @collection.length == 0
    end
    def is_Root?
      true
    end
    def redtar
      @@start_symbol
    end
    def collect_pterm(pterm)
      Root.new(@collection + [pterm])
    end
    def inspect
      'Root' + @collection[0].inspect
    end
  end
  class Branch
    attr_reader :rule, :collection # 解析木を見て計算するときに使う。
    def initialize(rule, collection)
      @rule = rule
      @collection = collection # 回収した文字を格納するための Array.
    end
    def completed?
      @rule[1].length == @collection.length
    end
    def not_completed?
      @rule[1].length >  @collection.length
    end
    def is_Root?
      false
    end
    def redtar
      @rule[1][@collection.length]
    end
    def gsym # abbrev: grammar symbol 文法記号
      # completed のときにのみ呼ぶこと。 completed のときに self が表す非終端文字を返す
      @rule[0]
    end
    def collect_pterm(pterm)
      Branch.new(@rule, @collection + [pterm])
    end
    def inspect
      #puts('debugwrite in Branch#inspect : @collection : '+@collection.inspect)
      # '|' の手前
      collection_str = @collection.map{|pterm| pterm.inspect }.join
      # '|' の後を付け加えて body_str を作る。
      j = @collection.length
      body = @rule[1]
      body_str =
        collection_str +
        (j<body.length ? '|' + body[j..-1].map{|gsym| gsym.inspect }.join : '' )
      # 返す。
      "[#{@rule[0].inspect}=#{body_str}]"
    end
  end

  module_function :set_grammar!, :parse
end # end of module Parser

def the_completed_pterm(poss_ary)
  # poss_ary から完成した木を一つ取り出す。
  # 曖昧さのない RULESET の下で、
  # かつ poss_ary が完成した Poss (高々一つ)を含むときに使うこと。
  return poss_ary if poss_ary.is_a?(QError)
  trees = poss_ary.select{|poss|poss.root.completed?}
  if trees.length>=2
    QError.new('Parse error : ambiguous : trees : ' + trees.inspect)
  elsif trees.length==0
    QError.new('Parse error : possibilities are all incomplete.')
  else
    trees[0].root.collection[0]
  end
end







#------
# test
#------
if $0 == __FILE__
  include Parser

  require 'gsym'

  # vvv NonTerminal や Terminal などの module 内の class
  # vvv にアクセスできるか見てるだけ。

  #-------------------
  # 文法切り替え switch ... test しやすくするために
  #-------------------
  g_switch = ARGV[0] # 'g_ccca' or 'g_sum_mul'
  
  #--------------------------
  # 加法と乗法の優先順位付き文法
  #--------------------------
  if g_switch == 'g_sum_mul'
    E   = NonTerminal.new(:e)
    T   = NonTerminal.new(:t)
    F   = NonTerminal.new(:f)
    A   = Terminal.new(:a)
    ADD = Terminal.new(:+)
    MUL = Terminal.new(:*)
    OP  = Terminal.new(:'(')
    CP  = Terminal.new(:')')
    G_SUM_MUL =
      [[E, [E,ADD,T]], [E, [T]      ],    # e = e + t | t
       [T, [T,MUL,F]], [T, [F]      ],    # t = t * f | f
       [F, [A]      ], [F, [OP,E,CP]]     # f = a | ( e )
      ]
  end
  
  #----------
  # 文法その2
  #----------
  if g_switch == 'g_ccca'
    S   = NonTerminal.new(:s)
    T   = NonTerminal.new(:t)
    U   = NonTerminal.new(:u)
    V   = NonTerminal.new(:v)
    A   = Terminal.new(:a)
    B   = Terminal.new(:b)
    C   = Terminal.new(:c)
    G_CCCA =
      [[S, [U,A]  ], [S, [V,B]],   # s = u a | v b
       [T, [C,U,V]], [T, [C]  ],   # t = c u v | c
       [U, [V,T]  ], [U, [T]  ],   # u = v t | t
       [V, [U,T]  ], [V, [T]  ]    # v = u t | t
      ]
  end

  # #--------------------------
  # # $grammar & $start_symbol
  # #--------------------------
  # grammar      = (g_switch == 'g_sum_mul' ? G_SUM_MUL : G_CCCA)
  # start_symbol = (g_switch == 'g_sum_mul' ? E : S)

  if g_switch == 'g_sum_mul'
    # test (B)
    puts('gsym array : ' + [E,T,F,A,ADD,MUL,OP,CP].inspect)

    # test set_grammar! make_redposs
    set_grammar!( G_SUM_MUL, E )
    s = 'Parser::get_redposs[E][A]'
    puts("#{s} : " + eval(s).inspect)
    s = 'Parser::get_redposs[E][T]'
    puts("#{s} : " + eval(s).inspect)
  end

end
