desc: README for プログラミング言語 Quest












[目次]

0 各文書の説明
1 概要
2 注意
3 Quest を使う
  2.1 対話環境 qi
  2.2 プログラムを書いたファイルを実行する
4 チュートリアル
  (前半)
  4.1 Hello, World!
  4.2 条件分岐
  4.3 繰り返し
  4.4 関数
  4.5 配列と範囲
  (後半)
  4.6 空間
  4.7 参照と代入
  4.8 空間の定義
  4.9 dot(.) 呼び出し
  4.10 整数、配列、範囲に対する dot(.) 呼び出し
  4.11 空間内での評価
  4.12 他の Quest プログラムの利用
  4.13 その他
5 Quest の中身
  5.1 lexer
  5.2 eliminator
  5.3 fparser
  5.4 constructor
  5.5 evaluator
6 反省と今後の課題
7 言語作成の動機など












[0 各文書の説明]

README    : この文書では主に Quest の使い方を説明します。
FPARSER   : fparser の動きの解説です。
PROGNOTES : 主なプログラムに対する覚え書きです。

以下はサンプルコードです。 usage: ./quest sample*.qs で実行できます。

clsobj.qs    : Rect, Space という2つの空間を定義し、クラスとして用いています。
funcprog.qs  : 論文「なぜ関数プログラミングは重要か」に現れるコードを Quest で書くと？
projeuler.qs : Project Euler の問題を解いています。
leafsum.qs   : Leaf, Branch 空間で木を表現し、その葉の和を求めています。
mulinexpr.qs : 複数行にまたがる式の例を挙げています。
on_do.qs     : on_do 式の例を載せています。
primeseq.qs  : 素数を扱うためのライブラリです。 sample3.qs に dofile されています。

以下の3つのプログラムは [3 Quest を使う] で解説します。

quest : Quest のインタプリタです。
qi    : Quest の対話環境です。
qv    : quest と同じインタプリタですが、こちらはトップレベルで評価した式の値を出力します。

以下はこの3つを支えているプログラム群です。

gquest.rb       : Quest の文法を定めた module GQuest があります。
lexer.rb        : 字句解析用のメソッド match_action を提供します。
fparser.rb      : ほぼ任意の文脈自由言語を解析できるパーサです。
constructor.rb  : fparser で得た解析木からS式を作るメソッド rule_action を提供します。
evaluator.rb    : S式を評価する関数 s_eval を提供します。

redposs.rb      : fparser で用いるデータ @@redposs を予め計算しておくプログラムです。
redposs.dat     : redposs.rb で生成したデータを保存しておくためのファイルです。
qerror.rb       : エラーを表すオブジェクトのクラス QError を定義しています。
gsym.rb         : class NonTerminal と class Terminal を定義しています。
arraymethods.rb : 二つ以上の *.rb で呼ばれる追加の Array メソッドを定義しています。

次のファイルは Quest と直接には関係しません。

grammar.rb : fparser が認識できる文法の例をいくつも書いています。














[1 概要]

puts('Hello, World!')

Quest はプログラム言語です。
ファイル *.qs にコードを書き、それを ./quest *.qs で実行することができます。

整数、実数、文字列、配列、範囲、関数、名前空間を扱うことができます。
これらはすべて第一級のオブジェクトです。
……この言語の最大の特徴は、名前空間を第一級とする、というところにあります。
Quest は名前空間のことを単に「空間」と呼びます。

Quest は手続き的な言語です。
ところが、空間をいじくることで、クラスやオブジェクトの真似事をすることができます。














[2 注意]

Quest は Ruby で書かれています。
バージョンは ruby 1.8.2 (2004-12-25) [universal-darwin8.0] です(ruby -v)。

特に断らない限り、コマンドはこの README が置かれているディレクトリで打つものとします。

言葉の約束(用語)
- Quest 言語そのものを指すときには Quest と書きます。
  (後述のインタプリタプログラムは quest という名前です)














[3 Quest を使う]

{3.1 対話環境 qi}

./qi
と打つことでインタプリタを起動できます。
以下のように表示され、入力を待ちます。
                     qi : Quest interactive                   
              Type '#quit' when you want to exit.             
  > 
最後に現れた '> ' の後に式を入力してください。

Quest のコードはすべて何らかの名前空間の中で走りますが、
この対話環境で打った式はトップレベル空間という名前空間の中を走ります。

今のところ、1行で書かれた式のみ受け付けられます。



{3.2 プログラムを書いたファイルを実行する}

./quest test.qs
と打つことで、プログラム test.qs を実行できます。

./qv test.qs
と打って、トップレベルで評価した式の値をいちいち表示させることもできます。

プログラムファイルの拡張子は qs です。















[4 チュートリアル]

Quest プログラムの書き方を説明します。
qi を起動しておくことで、サンプルコードの動きを確かめることができます。



{4.1 Hello, World!}

> puts('Hello, World!')
と打てば標準出力に Hello, World! と出て、改行されます。
puts は関数です。関数を呼ぶときには必ず丸括弧()をつけてください。

> 1111*1111 % (123 + 876 + 1)
四則演算を行うことができます。

> var = 3; var*var   #=> 9     ... sharp(#) で行コメントを書くことができます。
変数を定義できます。変数名は英字、数字、アンダースコアの1文字以上の並びで表現します。
ただし変数名の頭文字は英字かアンダースコアでなければなりません。
また以下に示す予約語と同じ名前も使えません。

予約語：
if, then, elsif, else, end, fun, true, false, space, init, nil, and, or, not

> [3,9] ++ [-2,-6]                      #=> [3, 9, -2, -6]
> 'single' ++ ' simple ' ++ 'sample'    #=> "single simple sample"
配列、文字列を扱えます。その連結には ++ を使います。



{4.2 条件分岐}

> if <条件式> then <1本以上の式(then節)> end                              (1)
> if <条件式> then <1本以上の式(then節)> else <1本以上の式(else節)> end     (2)
と打てばif式を使うことができます。

例：
> if true then puts("I'll be puts.") else puts("I won't be puts.") end

true, false は真偽値です。
<条件式> には必ず true か false の値をとる式を書かなければなりません。
> if 1 then 2 end
は Error となります。

Quest には文がありません。式だけです。ゆえに if は式の値を持ちます。
(1)の場合、then節が評価された場合には、そこで最後に評価された式の値を返し、
さもなくば false を返します。
(2)の場合、then節かelse節のどちらか一方が評価された後、
そこで最後に評価された式の値を返します。

elsif を使うこともできます。
> if <条件式> then <then節> elsif <elsif節> end
「elsif <elsif節>」はいくつ入れても構いません。入れなくても構いません。

論理演算子 and, or, not を使うことができます：
> false and false or true or false   #=> true
> not true                           #=> false



{4.3 繰り返し}

繰り返し用の特別な式は今のところありません。

後で触れる範囲(Range)を使えば
> (1..5).inject(nil, fun(_,i) puts(i.to_s) end)
という形で繰り返しを行うことができます。



{4.4 関数}

関数を定義するには
> fun <関数の名前> ( <0個以上のパラメタ> ) <1本以上の式> end
と打ってください。
関数 f は f(<0個以上の引数>) の形で呼び出せます。
呼ぶと <1本以上の式> が順に評価され、最後に評価された式の値が関数の値として返ってきます。

例：
> fun square_sum(x,y) x*x + y*y end
> square_sum(3,4)  #=> 25

関数は第一級のオブジェクトです。
関数を変数に代入したり、関数を関数の引数として渡したりできます。
上の例は次のように書いても同じ意味になります：
> square_sum = fun(x,y) x*x + y*y end

例：
> fun f(g) g(g(3,7),g(123,456)) end
> f(fun(x,y) x+y end)

再帰的な関数が書けます：
> fun gcd(a,b) r = a%b; if r==0 then b else gcd(b,r) end end
> gcd(2*5*5*11*23*31, 3*5*7*11*13*17)    #=> 55



{4.5 配列と範囲}

> a = [2,3,5,7,11]
> r = 0...4
と打つことで配列と範囲を生成できます。配列の要素は
> a[2]      #=> 5
> a[r]      #=> [2, 3, 5, 7]
> a[1..2]   #=> [3, 5]
> a[1..-2]  #=> [3, 5, 7]
で参照できます。



{4.6 空間}

Quest プログラムのコードはすべていずれかの空間内で走ります。
最初はトップレベル空間(toplevel space)の中を走ります。

if式の条件式が満たされるたびに新しい空間が生成され、
対応するthen節,elsif節,else節はその中で評価されます。
また関数を呼ぶたびに新たに空間が生成され、関数のコードがその上で実行されます。

生成された空間を取得することもできます。
関数のコードの最後の式(値を返す式)を @s にしてください(self)。
@s は「現在の空間」を表していて、
これにより関数のコードが実行されていた空間を得る事ができます。
この @s は関数が生みだしたものに限らず、すべての空間が持っています。

ほとんどの空間は親を持ちます。これもまた空間です。
親空間は @p で取得できます(parent)。

トップレベル空間は基底空間(base space)を親に持ちます。
基底空間の中には Quest における基本的な関数(puts など)が入っています。
そして基底空間は親を持ちません。

「取得」という表現からも伺える通り、Quest において空間は第一級のオブジェクトです。
空間を変数に代入したり、空間を関数の引数として渡したりできます。



{4.7 参照と代入}

コードの実行中に変数を参照するとき、その空間でその変数が見つからなければ、
今度は親空間へ探しにいきます。
そうやって親空間をたぐっていき、それでも変数が見つからなかった場合はエラーになります。

例：
> n=5; (fun(k) n*k end)(3)   #=> 15
(関数が呼ばれるたびに生成される空間は、関数が定義された空間を親に持ちます)

空間内の変数を見るには「colon(:) 取り出し」を用います。
空間を収めた変数 s とその中の変数 x があるとき、s:x はその変数 x の値を返します。
s は上で述べた形での変数の参照になり、親空間までたぐっていきますが、
x については s の中だけを探します
(それゆえ、これを「参照」と書いていないのです。これは「取り出し」です)。

例：
> sp = (fun(n) @s end)(7)  #=> (n=7 を含む空間)
> sp:n                     #=> 7
> x = 3
> sp:x   #=> Error     ... sp の中に x は無い(親をたぐっていけば見つかる)。

代入(=)の左辺も、それが評価されている空間内のみを探します。
もし見つからなければ新たにその変数がその空間において作られ、その上で代入がなされます。
colon(:) で取り出した変数に代入することもできます。

例1：
> a='apple'; if true then    a='banana' end; a   #=> "apple"
> a='apple'; if true then @p:a='banana' end; a   #=> "banana"

例2：
> adder = (fun(n) fun(i) @p:n = @p:n + i end end)(5)
> adder(11) #=> 16
> adder(22) #=> 38

「参照するとき」には親空間まで探しにいくが、
「取り出すとき」「代入するとき」にはその変数がある空間を「ここに」持ってこなければならない、
というわけです。
変数の値を変えるとき「どの変数が実際に変更されるのか」が分かりやすい方がよいと思うのです。



{4.8 空間の定義}

あなたは空間を自前で定義することができます。
> space <空間の名前(識別子)> init <1本以上の式(init節)> end
と打ってください。
空間が作られ、その中でinit節が実行され、最後にその空間が返ってきて
<空間の名前(識別子)> に代入されます。

空間 S の中で近所代入(=)した変数 a は S:a でアクセスできます(colon(:) 取り出し)。

例：
> space X init a=53; fun f(x) a%x end end
> X:f(7)    #=> 4
> X:a = 57
> X:f(11)   #=> 2

空間は第一級のオブジェクトです。
ゆえに、上記の空間定義は次のように書いても同じ意味になります：
> X = space a=53; fun f(x) a%x end end
(無名の空間を作る場合、init は書きません)

新たに生まれた空間はそれを生成する式を評価した空間を親(@p)として持ちます。
init節において @p に他の空間を代入することで、継承の真似事ができます。
sample1.qs を qv で実行してみてください： ./qv sample1.qs



{4.9 dot(.) 呼び出し}

sample1.qs で用いている r.area, s.area という式は「dot(.) 呼び出し」といい、
一般に x.a または x.a(<0個以上の引数>) という形をとります。
その心は「xにaをさせる」です。
(必ず関数呼び出しの意味になるため、引数がない場合は x.a のように丸括弧なしで書けます)
a には必ず関数を収めた変数名を与えてください。
x には基本的に何でも与えられます。

x が空間である場合：
x から初めて親空間をたぐっていき、関数 a を見つけ、呼びます。

x が空間でない場合：
「xの親空間」から初めて親空間をたぐっていき、関数 a を見つけ、呼びます。
整数、実数、配列、範囲の親空間は、それぞれ Integer, Real, Array, Range です。

dot(.) 呼び出しにおいて生成される空間は @r = x を含みます。
そのため、関数 area のコードは @r を見ることができるのです(receiver)。

sample1.qs を見れば分かるように、 dot(.) 呼び出しを用いることで
クラスシステムの真似事ができます。



{4.10 整数、配列、範囲に対する dot(.) 呼び出し}

整数の親空間 Integer 内で定義された関数の適用例：
> 1.to_s    #=> "1"
> (-1).abs  #=> 1
> 0.parent  # Integer 空間を返します。

配列の親空間 Array 内で定義された関数の適用例：
> [1,2,3].to_s                              #=> "[1, 2, 3]"
> [4,8,1].map(fun(n) n*n end)               #=> [16, 64, 1]
> [2,3,5,7,11].inject(0, fun(x,y) x+y end)  #=> 28

範囲の親空間 Range 内で定義された関数の適用例：
> (1...3).to_s                        #=> "1...3"
> (1..10).map(fun(k) 23%k end)        #=> [0, 1, 2, 3, 3, 5, 2, 7, 5, 3]
> (1..7).inject(1, fun(x,y) x*y end)  #=> 5040



{4.11 空間内での評価}

あなたは既存の空間を持ってきて、その上でコードを走らせることができます。
on <空間> do <1本以上の式> end
と打つことで、 <空間> 内で <1本以上の式> を評価することができます(on_do 式)。
これは既存の空間を変容させられるということを意味します。

例：
> on Integer do fun sq() @r*@r end end
> 5.sq    #=> 25

上のコードは、実は
> Integer:sq2 = fun() @r*@r end
> 5.sq2
と打っても25を返しますが、若干意味は異なります。

前者における fun は Integer 空間内で作られるため、 Integer 空間を親に持ちます。
一方後者における fun はトップレベルで作られるため、トップレベルを親に持つことになります。



{4.12 他の Quest プログラムの利用}

dofile 関数を使うことで、他のファイルに書かれた Quest プログラムを読み込むことができます。

例1：
dofile('mulinexpr.qs', @s)

dofile はファイル名と空間を引数にとり、
その空間上でファイル名で指定されたプログラムを走らせます。

例2：
P = dofile('primeseq.qx', space end)
P:PrimeSeq:getp(5)  #=> 11

dofile は引数として渡した空間を返すため、上のように空の空間上でプログラムを走らせられます。
この方法の利点は dofile するプログラムの側で名前の衝突回避を行えるところにあります。



{4.13 その他}

以下に演算子を結合力の強い方から並べます。
K&R に載っている式の文法(p244~;A7)や Ruby の演算子の強弱関係を
ほぼそのまま取り込んでいます。

後置演算子( 関数呼び出し(f(a)), 部分参照(a[i]), dot(.), colon(:) )
単項演算子( 単項プラス(+a), 単項マイナス(-a) )
乗法演算子( * / % )
加法演算子( + - ++ )
関係演算子( <= >= < > )
等値演算子( == != )
範囲演算子( ... .. )
if式
fun生成式
space生成式
代入演算子(=)
論理not
論理and
論理or












[5 Quest の中身]

{5.1 lexer}

プログラムを成す文字列からトークンを切り出してトークン列を作ります。
トークンの認識には正規表現を用いています。

例：
> e=5
> if true then
>   e
> else 0 end
#=> IDEN SUBST INTEGER SEP 
    IF QTRUE THEN SEP
    IDEN SEP
    ELSE INTEGER QEND

{5.2 eliminator}

トークン列から不要なトークンを取り除きます。
これのお陰で後続の fparser の文法が単純・直截に書けています。

例： IDEN SUBST INTEGER SEP IF QTRUE THEN SEP IDEN SEP ELSE INTEGER QEND
#=> IDEN SUBST INTEGER SEP IF QTRUE THEN     IDEN     ELSE INTEGER QEND

{5.3 fparser}

上向きの構文解析器です。
lexer で得たトークン列を読み込んで解析木を作ります。
Yacc などに使われている LALR のアルゴリズムではなく、
(naive ですが)独自の実装を施しています。

動きについては FPARSER をご覧下さい。

{5.4 constructor}

パーサで作った解析木から、Array の形で表されたS式を構築(cons)します。

{5.5 evaluator}

Array をS式に見立てて評価します。
SICP (Structure and Interpretation of Computer Programs) の
Chapter 4 に載っている Metacircular Evaluator を参考にしています。













[6 反省と今後の課題]

- 繰り返し用の式(loop)を作る。制御式(break)を作る：
  let i=0 loop if i<5 then @p:i+=1 else break end; puts(i.to_s) end
  - break を作るには evaluator の動き方を考え直さねばならない。
    s_eval は sexp のみを引数にとり、 cns は module 変数 @@cns にするだろう。
    つまり module で包むだろう。

- where を作る：
    (1..100).inject(1,_) where fun _(x,y)
      x*y
    end
  と書けるようにする。

- gquest.rb のコメントにあるような形で書いた文脈自由文法から文法を自動生成する。
  ... 文法(規則集)を書くための文法(言語)

- fparser は幅優先で解析を行っているが、これは深さ優先でやった方がスマートだろう。

- エラー処理：エラーが起こった行番号を表示する。
  ... token に行番号のデータを持たせる。

- code を第一級のオブジェクトにする ... macro を扱えるようにしてみる。

- space の変数を非公開にできるようにする。   ... private

- @p より高度な親アクセスの仕組み。
  「ある空間をたぐって見つからなければ他の親を探す」など。
  一般化： @p を親アクセスの手続きを定めた関数にする。













[7 言語作成の動機など]

Quest を使う上で知らなくてよいことを最後の方に持ってきました。

この言語の名前は、私が今まで触れてきたプログラミング言語に対して抱いた
疑問(Question)と、それに挑む探検(Quest)からとっています。
単に頭文字に珍しいアルファベットを使いたかっただけ、というのもありますが……。

既存の言語を学んでく中で、私の中でなんとなく漠然とした疑念が湧いてきていました。
そこで私はプログラム言語そのものに対する理解を深めるために、この言語を作りました。
理解のために用いたやり方は「すでによく親しんだ概念を基礎とする」です。



{理解するために作る。作って理解する}

数値、文字列、シンボル、範囲、配列、ハッシュに比べ、
クラスとオブジェクト、それにモジュールの概念は分かりづらいと思っていました。
前者五つは、それを使えるどの言語においても似たような意味を持っていましたが、
後者三つは言語によって意味が異なっていて、言語毎に学び直す必要がありました。
Quest ではこの概念を理解するために、
(クラスなどに比べれば)意味のはっきりしている「名前空間」に触れるようにしたのです。



{文法について}

「見かけからして曖昧さがない」ように気をつけています。
if 式において then を強制しているのは、
この辺の「区切り」を明確にしておきたいがためなのです。

Lisp のコードは括弧が多く煩雑に見えますが、
括弧が多いお陰で誤読の可能性がほとんどありません。
これは「始め(丸括弧開き)」「区切り(空白)」「終わり(丸括弧閉じ)」
がはっきりしているからだと思います。

Quest ではこの点をふまえ、例えば if, fun, space 式において
「始め(if,fun,space)」「区切り(then,elsif,etc.)」「終わり(end)」
を陽に書かせています。

中括弧({})を使ったC的な記法は else 節を書く際に行数を節約しようとすると
if () {
  do_something_1
} else {
  do_something_2
}
となって2文字の字下げを用いているときに節の区切りが見づらく感じるので、
採用しませんでした。



{注力したところについて}

文法と意味論に注力しています。
実行速度(計算量)に関しては最低限のことだけをしています(redposs を予め計算しておく、など)。

(文法)

私は以前から文脈自由文法(のサブセット)を扱うパーサを作ってみたいと思っていました。
そこで計算理論の本やドラゴン本を見たのですが、
一般的な文脈自由文法を直に扱える簡潔な方法(ただし計算量の問題は放置)を見出せませんでした。

上向き解析器は SLR でさえやたら複雑で、
下向き解析器やCYKアルゴリズムだと文法を変形させねばならず、
解析木から意味を引き出す時に難渋しそうでした
(言語作成の入門書では大抵下向きの解析木を用いていて、そんなに難しくはないようですが)。

文脈自由文法そのものは非常に単純に表現できるのに、
それを扱うアルゴリズムがその単純さを反映できていないような気がしたのです。

今回実装した fparser は文法にやや制限がある(空文字列を生成する規則が扱えない)ものの、
やっていることは「他の上向き解析器に比べれば」複雑でなく、
CYKアルゴリズムのように文法を変形させる必要がなく、
下向き解析器のように左再帰について考える必要がありません(e=e+t などをそのまま扱える)。

(意味論)

今まで私が言語に対して抱いた疑問のほとんどは、意味論の問題に分類されるものでした。
- コードはどうやって動いているのか？
- クロージャはどう動いているのか？
- 型やクラスやオブジェクトはどう動いているのか？　名前空間に似ていないか？
- スコープの定め方をもっと単純にできないか？　言語によって少しずつ異なるせいで混乱しやすい。

Quest をC言語などの、より low-level の言語で実装しなかったのは、
始めはとにかく意味論の問題に注力したかったためです。
はじめから強力な意味を持っている言語を用いた方が実装しやすく、
また目的言語との差異が計りやすいため
(後々もっと早い言語で実装する時の)理解の助けにもなると思ったのです。


