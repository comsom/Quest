# date: 7;2011/2/12 (sat)

# CalcPoss 内にあった class NonTerminal と class Terminal を gsym.rb に移した。

class Array
  def omit(&pred)
    # delete_if は破壊的であるため、破壊的でないメソッドを作る。
    self.select{|x| not pred.call(x) }
  end
  def concatall(&proc)
    # self (Array)の各要素に対し Array を返す proc を適用して、
    # 帰ってきた Array たちを + でつなげたものを返す。
    self.inject([]) {|acc,x| acc + proc.call(x) }
  end
  def setminus(set) # for: firstnts_inner
    self.omit{|x| set.include?(x) }
  end
end

module CalcPoss # poss :abbrev: possibility 可能性

  @@ruleset      = :undefined
  @@start_symbol = :undefined
  @@redposs      = :undefined # abbrev: reduction possibility 還元可能性
  def get_redposs # to test @@redposs
    @@redposs
  end
  def set_grammar!(rs,ss)
    @@ruleset      = rs
    @@start_symbol = ss
    # ^^^以上が grammar を成す。以下ではこれらから予め計算しておけるものを計算しておくvvv
    @@redposs      = make_redposs()
  end
  def make_redposs
    # res[redtar][gsym] でもって、
    # その頭部が firstnts(redtar) に含まれ、かつその本体が gsym で始まるような rule
    # をすべて集めた配列を返すような res を作るためのメソッド。
    # 1. 準備
    nonterminals = @@ruleset.map{|rule| rule[0] }.uniq          # 非終端記号全て
    gsyms = @@ruleset.concatall{|rule| [rule[0]]+rule[1] }.uniq # 文法記号全て
    # 2. hash の生成
    nonterminals.inject({}) {|res, redtar|
      res[redtar] = gsyms.inject({}) {|acc, gsym|
        acc[gsym] = @@ruleset.select{|rule|
          ([redtar] + firstnts(redtar)).include?(rule[0]) and rule[1][0] == gsym
        }
        acc
      }
      res
    } 
  end
  def firstnts(nonterminal) # nts :abbrev: nonterminals
    # nonterminal から生成される文法記号列の
    # 先頭に現れうる非終端文字をすべて集めた配列を返す
    firstnts_inner([], [nonterminal])
  end
  def firstnts_inner(res, news)
    # res  : 今までに得た非終端文字を貯めておくための配列。
    # news : これから試す非終端文字の queue
    #  n   : news[0] が直接生成する文法記号列の頭にある非終端記号をすべて集め、
    # vvv   その集合からすでに得ている res の記号を取り払ったもの。
    n = heads_of_dirder(news[0]).
      select{|gsym| gsym.is_nonterminal? }.setminus(res)
    next_news = news[1..-1] + n
    if next_news.any?
      firstnts_inner(res+n, next_news)
    else
      res+n
    end
  end

  def heads_of_dirder(nonterminal) # dirder :abbrev: direct derivation
    # self が直接導出する文法記号列の頭にある記号をすべて返す。
    @@ruleset.select{|rule| rule[0] == nonterminal }.map{|rule| rule[1][0] }
  end

  #---------------
  # calc_poss_ary
  #---------------
  # poss_ary の計算 calc_poss_ary
  #   poss_ary の中の Root が完成していない各 poss について inject :
  #     calc_poss(poss) を返す。
  def calc_poss_ary(poss_ary)
    poss_ary.omit{|poss| poss.root.completed? }.concatall {|poss|
      calc_poss(poss)
    }
  end
  
  #-----------
  # calc_poss
  #-----------
  def calc_poss(poss)
    if poss[-2].redtar.is_nonterminal? # abbrev: reduction target 還元目標
      # 還元可能性の生成(とその後の処理)
      @@redposs[poss[-2].redtar][poss[-1].gsym].concatall {|rule|
        new_poss = poss[0...-1] << Branch.new(rule, [poss[-1]])
        # 回収可能性の生成(とその後の処理)
        collectposses_then_postprocess(new_poss)
      }
    elsif poss[-2].redtar.is_terminal?
      # 還元可能性の生成(とその後の処理)
      if poss.reach2redtar?
        new_poss = poss.collect
        # 回収可能性の生成(とその後の処理)
        collectposses_then_postprocess(new_poss)
      else
        []
      end
    else
      abort 'Abort in calc_poss'
    end
  end
  
  #--------------------------------
  # collectposses_then_postprocess
  #--------------------------------
  def collectposses_then_postprocess(new_poss)
    # new_poss を可能なだけ回収し、その途上で現れる各可能性に対し計算を行う。
    collect_seq(new_poss).concatall {|p|
      if p[-1].is_Root? or p[-1].not_completed?
        [p]
      elsif p[-1].completed?
        calc_poss(p)
      end
    }
  end
  def collect_seq(poss)
    # poss を回収して得られる可能性の列を返す。
    acc = [poss]
    while true
      p = acc[-1] # abbrev: poss
      #puts('debugwrite in collect_seq : p : ' + p.inspect)
      if p[-1].is_Root?
        break
      elsif p[-1].completed? and p.reach2redtar?
        acc << p.collect
      else
        break
      end
    end
    #puts('debugwrite in collect_seq : acc : ' + acc.inspect)
    acc
  end

  #------
  # Poss
  #------
  class Poss < Array
    def initialize(poss)
      # puts('debugwrite in Poss#initialize : self.is_a?(Array) : ' +
      #      self.is_a?(Array).inspect)
      # puts('debugwrite in Poss#initialize : self.class.superclass : ' +
      #      self.class.superclass.inspect)
      # puts('debugwrite in Poss#initialize : self.methods.sort : ' +
      #      self.methods.sort.inspect)
      self << poss.shift until poss.length == 0
    end
    def root
      self[0]
    end
    def collect
      Poss.new( self[0...-2] << self[-2].collect_pterm(self[-1]) )
    end
    # ^^^ pterm :abbrev: poss's term : poss の各要素になりうる object のこと ^^^
    # いいかえると、 Root または Branch または Terminal のこと。
    # NonTerminal は pterm にはなり得ないことに注意(Branch に吸収されるため)。
    def reach2redtar?
      #puts('debugwrite in reach2redtar? : poss : ' + self.inspect)
      self[-2].redtar == self[-1].gsym
    end
    def inspect
      if self.length > 1
        self[1..-1].map{|pterm| pterm.inspect }.join(':')
      elsif self.length == 1
        self[0].inspect # Root の inspect
      end
    end
  end
  
  #---------------
  # Root & Branch
  #---------------
  class Root
    attr_reader :collection # 解析木を見て計算するときに使う。
    def initialize(collection=[])
      # 開始記号はモジュール変数 @@start_symbol にいれておく。
      @collection = collection
    end
    def completed?
      @collection.length == 1
    end
    def not_completed?
      @collection.length == 0
    end
    def is_Root?
      true
    end
    def redtar
      @@start_symbol
    end
    def collect_pterm(pterm)
      Root.new(@collection + [pterm])
    end
    def inspect
      'Root' + @collection[0].inspect
    end
  end
  class Branch
    attr_reader :rule, :collection # 解析木を見て計算するときに使う。
    def initialize(rule, collection)
      @rule = rule
      @collection = collection # 回収した文字を格納するための Array.
    end
    def completed?
      @rule[1].length == @collection.length
    end
    def not_completed?
      @rule[1].length >  @collection.length
    end
    def is_Root?
      false
    end
    def redtar
      @rule[1][@collection.length]
    end
    def gsym # abbrev: grammar symbol 文法記号
      # completed のときにのみ呼ぶこと。 completed のときに self が表す非終端文字を返す
      @rule[0]
    end
    def collect_pterm(pterm)
      Branch.new(@rule, @collection + [pterm])
    end
    def inspect
      #puts('debugwrite in Branch#inspect : @collection : '+@collection.inspect)
      # '|' の手前
      collection_str = @collection.map{|pterm| pterm.inspect }.join
      # '|' の後を付け加えて body_str を作る。
      j = @collection.length
      body = @rule[1]
      body_str =
        collection_str +
        (j<body.length ? '|' + body[j..-1].map{|gsym| gsym.inspect }.join : '' )
      # 返す。
      "[#{@rule[0].inspect}=#{body_str}]"
    end
  end

  module_function :set_grammar!, :calc_poss_ary
end # end of module CalcPoss



#------
# test
#------
if $0 == __FILE__
  include CalcPoss

  require 'gsym'

  # vvv NonTerminal や Terminal などの module 内の class
  # vvv にアクセスできるか見てるだけ。

  #-------------------
  # 文法切り替え switch ... test しやすくするために
  #-------------------
  g_switch = ARGV[0] # 'g_ccca' or 'g_sum_mul'
  
  #--------------------------
  # 加法と乗法の優先順位付き文法
  #--------------------------
  if g_switch == 'g_sum_mul'
    E   = NonTerminal.new(:e)
    T   = NonTerminal.new(:t)
    F   = NonTerminal.new(:f)
    A   = Terminal.new(:a)
    ADD = Terminal.new(:+)
    MUL = Terminal.new(:*)
    OP  = Terminal.new(:'(')
    CP  = Terminal.new(:')')
    G_SUM_MUL =
      [[E, [E,ADD,T]], [E, [T]      ],    # e = e + t | t
       [T, [T,MUL,F]], [T, [F]      ],    # t = t * f | f
       [F, [A]      ], [F, [OP,E,CP]]     # f = a | ( e )
      ]
  end
  
  #----------
  # 文法その2
  #----------
  if g_switch == 'g_ccca'
    S   = NonTerminal.new(:s)
    T   = NonTerminal.new(:t)
    U   = NonTerminal.new(:u)
    V   = NonTerminal.new(:v)
    A   = Terminal.new(:a)
    B   = Terminal.new(:b)
    C   = Terminal.new(:c)
    G_CCCA =
      [[S, [U,A]  ], [S, [V,B]],   # s = u a | v b
       [T, [C,U,V]], [T, [C]  ],   # t = c u v | c
       [U, [V,T]  ], [U, [T]  ],   # u = v t | t
       [V, [U,T]  ], [V, [T]  ]    # v = u t | t
      ]
  end

  # #--------------------------
  # # $grammar & $start_symbol
  # #--------------------------
  # grammar      = (g_switch == 'g_sum_mul' ? G_SUM_MUL : G_CCCA)
  # start_symbol = (g_switch == 'g_sum_mul' ? E : S)


  if g_switch == 'g_sum_mul'
    # test (B)
    puts('gsym array : ' + [E,T,F,A,ADD,MUL,OP,CP].inspect)

    # test set_grammar! make_redposs
    set_grammar!( G_SUM_MUL, E )
    s = 'CalcPoss::get_redposs[E][A]'
    puts("#{s} : " + eval(s).inspect)
    s = 'CalcPoss::get_redposs[E][T]'
    puts("#{s} : " + eval(s).inspect)
  end

end
